; Windows API functions
extern _GetStdHandle@4
extern _WriteConsoleA@20
extern _ReadConsoleA@20
extern _ExitProcess@4
extern _FindFirstFileA@8
extern _FindNextFileA@8
extern _FindClose@4
extern _SetCurrentDirectoryA@4
extern _GetCurrentDirectoryA@8

section .data
    prompt          db      'Enter directory path: ', 0
    search_pattern  db      '\*.*', 0
    directory_msg   db      'Directory: ', 0
    newline         db      13, 10, 0
    space           db      ' ', 0
    indent          db      '    ', 0
    dot_dir         db      '.', 0
    dotdot_dir      db      '..', 0
    buffer_size     equ     260

section .bss
    input_buffer    resb    buffer_size
    search_path     resb    buffer_size
    find_data       resb    318        ; WIN32_FIND_DATA structure
    find_handle     resd    1
    chars_written   resd    1
    chars_read      resd    1
    console_in      resd    1
    console_out     resd    1
    level           resd    1
    current_dir     resb    buffer_size

section .text
    global _main

_main:
    push ebp
    mov ebp, esp

    ; Get console handles
    push -10                        ; STD_INPUT_HANDLE
    call _GetStdHandle@4
    mov [console_in], eax

    push -11                        ; STD_OUTPUT_HANDLE
    call _GetStdHandle@4
    mov [console_out], eax

    ; Save current directory
    push buffer_size
    push current_dir
    call _GetCurrentDirectoryA@8

    ; Print prompt
    push prompt
    call print_string

    ; Read input
    push 0                          ; Reserved
    push chars_read                ; Number of chars read
    push buffer_size               ; Buffer size
    push input_buffer              ; Buffer
    push dword [console_in]        ; Console handle
    call _ReadConsoleA@20

    ; Null terminate input (remove CRLF)
    mov esi, [chars_read]
    sub esi, 2                     ; Remove CRLF
    mov byte [input_buffer + esi], 0

    ; Change to input directory
    push input_buffer
    call _SetCurrentDirectoryA@4
    test eax, eax
    jz .error_exit

    ; Print directory message
    push directory_msg
    call print_string
    push input_buffer
    call print_string
    push newline
    call print_string

    ; Initialize level
    mov dword [level], 0

    ; Start scanning
    call scan_directory

    ; Restore original directory
    push current_dir
    call _SetCurrentDirectoryA@4

.exit:
    push 0
    call _ExitProcess@4

.error_exit:
    push newline
    call print_string
    push 1
    call _ExitProcess@4

; Scan directory recursively
scan_directory:
    push ebp
    mov ebp, esp

    ; Find first file
    push find_data
    push search_pattern + 1        ; Skip the initial backslash
    call _FindFirstFileA@8
    mov [find_handle], eax
    cmp eax, -1
    je .done

.find_loop:
    ; Check if it's a directory
    mov eax, [find_data + 0]
    test eax, 10h
    jz .not_directory

    ; Skip . and ..
    lea esi, [find_data + 44]
    cmp byte [esi], '.'
    je .next_file

    ; Print directory name with indentation
    mov ecx, [level]
.indent_loop:
    test ecx, ecx
    jz .print_dir_name
    push ecx
    push indent
    call print_string
    pop ecx
    dec ecx
    jmp .indent_loop

.print_dir_name:
    push esi
    call print_string
    push dword 92                 ; Add directory separator
    call print_char
    push newline
    call print_string

    ; Recursively scan subdirectory
    push dword [level]
    inc dword [level]

    ; Change to subdirectory
    push esi
    call _SetCurrentDirectoryA@4

    call scan_directory

    ; Return to parent directory
    push dotdot_dir
    call _SetCurrentDirectoryA@4

    pop dword [level]
    jmp .next_file

.not_directory:
    ; Print filename with indentation
    mov ecx, [level]
.indent_file_loop:
    test ecx, ecx
    jz .print_filename
    push ecx
    push indent
    call print_string
    pop ecx
    dec ecx
    jmp .indent_file_loop

.print_filename:
    lea esi, [find_data + 44]
    push esi
    call print_string
    push newline
    call print_string

.next_file:
    push find_data
    push dword [find_handle]
    call _FindNextFileA@8
    test eax, eax
    jnz .find_loop

    push dword [find_handle]
    call _FindClose@4

.done:
    mov esp, ebp
    pop ebp
    ret

; Print string (null-terminated)
print_string:
    push ebp
    mov ebp, esp
    push ebx

    mov ebx, [ebp + 8]
    mov edx, ebx
    xor ecx, ecx
.count_loop:
    cmp byte [edx], 0
    je .count_done
    inc ecx
    inc edx
    jmp .count_loop
.count_done:

    push 0
    push chars_written
    push ecx
    push ebx
    push dword [console_out]
    call _WriteConsoleA@20

    pop ebx
    mov esp, ebp
    pop ebp
    ret 4

; Print single character
print_char:
    push ebp
    mov ebp, esp
    push ebx

    push 0
    push chars_written
    push 1
    push ebp
    add dword [esp], 8             ; Point to character parameter
    push dword [console_out]
    call _WriteConsoleA@20

    pop ebx
    mov esp, ebp
    pop ebp
    ret 4